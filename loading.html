<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Loading...</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            background-color: #222;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /***********************
         * Global Configuration
         ***********************/
        const CONFIG = {
            // Canvas settings
            canvasSize: 300,         // Both width and height (perfect square)

            // Bouncing shape properties
            shapeRadius: 32,         // Radius (or half-size for non-circular shapes)
            speed: 6,                // Base speed of the bouncing object
            shapes: ['circle', 'triangle', 'square'],
            initialShapeIndex: 0,    // Start with this shape from the array
            randomize: true,         // Random starting position and direction

            // Transition (on collision) parameters
            transitionDuration: 500, // Duration in milliseconds for the transition
            rotationAmount: Math.PI, // Half-rotation in radians (180°). Second half adds another Math.PI to complete 360°.
            minScale: 0.4,           // Smallest scale factor at the midpoint of the transition

            // Color properties
            colorCycleSpeed: 0.4,      // How fast the hue cycles per frame (in degrees)

            // Easing function for transitions (easeInOutQuad)
            easing: function (t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }
        };

        /***********************
         * BouncingShape Class
         ***********************/
        function BouncingShape(config) {
            this.config = config;
            this.canvasSize = config.canvasSize;
            this.radius = config.shapeRadius;

            // Randomize starting position if enabled, otherwise center it.
            if (config.randomize) {
                this.x = Math.random() * (this.canvasSize - 2 * this.radius) + this.radius;
                this.y = Math.random() * (this.canvasSize - 2 * this.radius) + this.radius;
            } else {
                this.x = this.canvasSize / 2;
                this.y = this.canvasSize / 2;
            }

            // Randomize velocity (using a random angle)
            const angle = Math.random() * Math.PI * 2;
            this.dx = Math.cos(angle) * config.speed;
            this.dy = Math.sin(angle) * config.speed;

            // Shape management
            this.shapes = config.shapes;
            this.currentShapeIndex = config.initialShapeIndex;

            // Transition properties
            this.transitionDuration = config.transitionDuration;
            this.rotationAmount = config.rotationAmount;
            this.minScale = config.minScale;
            this.inTransition = false;
            this.transitionStartTime = 0;
            this.transitionProgress = 0;
            this.currentRotation = 0;
            this.currentScale = 1;
            this.shapeChanged = false; // To change shape only once per transition
            this.rotationDirection = 1; // 1 for forward, -1 for backward

            // Color (using HSL for smooth hue transitions)
            this.hue = 0;
            this.colorCycleSpeed = config.colorCycleSpeed;

            // Easing function for transitions
            this.easing = config.easing;
        }

        BouncingShape.prototype.startTransition = function () {
            this.inTransition = true;
            this.transitionStartTime = performance.now();
            this.transitionProgress = 0;
            this.shapeChanged = false;
            // Randomly choose a rotation direction: 1 (forwards) or -1 (backwards)
            this.rotationDirection = Math.random() < 0.5 ? 1 : -1;
        };

        BouncingShape.prototype.updateTransition = function () {
            const now = performance.now();
            const elapsed = now - this.transitionStartTime;
            this.transitionProgress = Math.min(elapsed / this.transitionDuration, 1);
            const easedProgress = this.easing(this.transitionProgress);

            if (this.transitionProgress < 0.5) {
                // First half: scale down and rotate in the chosen direction (0 to rotationAmount)
                let p = easedProgress * 2; // normalize to [0,1]
                this.currentScale = 1 - p * (1 - this.minScale);
                this.currentRotation = this.rotationDirection * (p * this.rotationAmount);
            } else {
                // Second half: scale back up and continue rotating in the same direction
                let p = (easedProgress - 0.5) * 2; // normalized for second half [0,1]
                this.currentScale = this.minScale + p * (1 - this.minScale);
                // Continue rotation: add an additional rotationAmount so that the total is 2 * rotationAmount (360°)
                this.currentRotation = this.rotationDirection * (this.rotationAmount + p * this.rotationAmount);
                // At the midpoint, change the shape (only once)
                if (!this.shapeChanged) {
                    this.currentShapeIndex = (this.currentShapeIndex + 1) % this.shapes.length;
                    this.shapeChanged = true;
                }
            }

            // End transition when complete.
            if (this.transitionProgress >= 1) {
                this.inTransition = false;
                this.currentScale = 1;
                // Reset rotation after a full 360° (optional)
                this.currentRotation = 0;
                this.transitionProgress = 0;
                this.shapeChanged = false;
            }
        };

        BouncingShape.prototype.update = function (deltaTime) {
            // Update position using a frame-rate–independent multiplier (assuming ~60fps baseline)
            this.x += this.dx * (deltaTime / 16.67);
            this.y += this.dy * (deltaTime / 16.67);

            // Update hue for continuous color cycling
            this.hue = (this.hue + this.colorCycleSpeed) % 360;

            // Detect wall collisions
            let collided = false;
            if (this.x + this.radius > this.canvasSize || this.x - this.radius < 0) {
                this.dx = -this.dx;
                collided = true;
            }
            if (this.y + this.radius > this.canvasSize || this.y - this.radius < 0) {
                this.dy = -this.dy;
                collided = true;
            }

            // Start a transition if a collision occurs and none is active
            if (collided && !this.inTransition) {
                this.startTransition();
            }

            // If in transition, update its progress
            if (this.inTransition) {
                this.updateTransition();
            }
        };

        BouncingShape.prototype.draw = function (ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.currentRotation);
            ctx.scale(this.currentScale, this.currentScale);
            ctx.fillStyle = `hsl(${this.hue}, 100%, 50%)`;

            const shape = this.shapes[this.currentShapeIndex];
            if (shape === 'circle') {
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape === 'triangle') {
                ctx.beginPath();
                const angleOffset = -Math.PI / 2;
                for (let i = 0; i < 3; i++) {
                    const theta = angleOffset + i * (2 * Math.PI / 3);
                    const px = this.radius * Math.cos(theta);
                    const py = this.radius * Math.sin(theta);
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.closePath();
                ctx.fill();
            } else if (shape === 'square') {
                ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
            }
            ctx.restore();
        };

        /***********************
         * Animation Setup
         ***********************/
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CONFIG.canvasSize;
        canvas.height = CONFIG.canvasSize;

        // Create our bouncing shape instance using CONFIG
        const bouncingShape = new BouncingShape(CONFIG);
        let lastTime = performance.now();

        function animate() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            bouncingShape.update(deltaTime);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            bouncingShape.draw(ctx);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
